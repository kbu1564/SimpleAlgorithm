#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;

int rb[111111];
int main() {
	int zz;

	cin>>zz;
	for(int tc=1; tc<=zz; tc++) {
		int n,r,s;

		scanf("%d %d %d",&n,&r,&s);
		for(int i=0; i<n; i++) scanf("%d",&rb[i]);

		// 최대 이동거리가 최소인 이동거리를 INF 라는 가정하에
		// 커버 될때의 남은 감시 구역의 최소값을 구하고 남은 양으로 그보다 적은 이동거리로 커버 되는지를 체크

		// h : 로봇이 이동한 거리중 최대가 최소인 거리
		long long l = 0, h = 2e9;
		while(l < h) {
			// 이분탐색같이 적용한 듯한데...
			// 절반씩 최대가 최소인 거리를 INF 부터 줄여나가는 식으로 탐색
			long long m = (l+h)/2, total = 0;
			// 모든 로봇이 전부 최소 이동거리가 최대 만큼 이동한다는 가정하에 움직이도록
			for(int i=0; i<n; i++) {
				// [0, total] 감시가 가능한지 체크

				// 아래 조건이 만족하지 않으면 로봇이 최대 m번 이동하여 감시 구역으로 포함될 수 없음을 의미한다.
				// 아래 조건은 로봇이 m번 최대 m번 이동으로 도착지점인 total 위치에 다다를 수 있는지를 검사
				if(rb[i]-m-r <= total && total <= rb[i]+m+r) {
					// 로봇이 최대 만큼 이동 했을 때 감시 범위안에 들어와 있어야 한다.

					// 만약 m만큼 이동으로 감시 범위에 다다를 수 있다면?
					// 다음 로봇의 도착지점의 위치를 갱신
					// rb[i]-m-r 지점과 rb[i]+m+r 지점 중 다음 지점으로 될 rb[i]+m+r이 total+2*r보다 작다면??
					// 다음 지점은 작은 값이 되야만 한다!
					total = min(rb[i]+m+r, total+2*r);

					/*
					X : 로봇의 위치
					1      2                                    X
					|------|------|------|------...------|------|------|
					0            total
					만약 이전에 로봇이 total 보다 오른쪽에 있었다면,
					현재 로봇이 X위치에 있다면 1번 위치로 가는것 보다 2번 위치로 가는것이 최대이동거리가 최소가 되는 지점이다.
					따라서 오른쪽에 있다면 다음 로봇은 total+2*r 위치에 도착해야하며

					         X                                  1      2
					...------|------|------|------|------|------|------|-----...
					                                     0            total
					만약 이전에 로봇이 total 보다 왼쪽에 있었다면,
					현재 로봇이 X위치에 있다는 가정하에 1번 위치로 가는것이 2번 위치로 가는것보다 최대 이동거리가 최소가 되는 지점이다.
					따라서 왼쪽에 있다면 다음 로봇은 (로봇의 이전위치)+(최대이동거리)+(감시범위r)에 위치해야 한다.

					따라서 위 if 문 조건을 만족하는 로봇의 다음 도착 위치는 rb[i]+m+r와 total+2*r중 최소값이 되어야만 한다.
					*/
				}
			}

			// total 이 커버하려는 범위인 s만큼 되었다면? 그때의 최소이동이 최대인 거리를 출력
			// 감시 해야하는 범위가 아직 남았다면 값이 -1(불가능)이어야 하므로

			// 최대 이동 m 으로 전 감시구역 커버가 가능하면 보다 큰 범위 커버가 가능한지 체크
			// 보다 큰 범위가 불가능 하다면 그보다 적은 거리를 기준으로 절반씩 비교 검사
			if(total >= s) h=m; // 만약 가장 긴 이동거리가 m 인 로봇들로 감시 구역 커버가 가능하다면 [l, m] <- 결과적으로 다음번 m이 감소하는 효과
			else l=m+1; // 만약 가장 긴 이동거리로 감시 구역 커버가 불가능 하다면 [m+1, h] <- 결과적으로 다음번 m이 증가하는 효과
		}
		cout<<"Case #"<<tc<<"\n";
		// 최대가 최소인 거리가 INF라면 범위를 커버하지 못함
		if(h==2e9) cout<<"-1\n";
		else cout << h<<"\n";
	}
}
